{"seeAlsoSections":[{"identifiers":["doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/quick-start","doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/advanced-retry-strategies","doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/RetryPolicyService"],"title":"Related Documentation","anchor":"Related-Documentation"},{"generated":true,"identifiers":["doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/installation","doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/quick-start","doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/advanced-retry-strategies"],"title":"Articles","anchor":"Articles"}],"primaryContentSections":[{"content":[{"type":"heading","level":2,"text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"This guide covers best practices, common pitfalls, and recommended patterns for implementing retry logic in production applications.","type":"text"}]},{"type":"heading","level":2,"text":"Strategy Selection","anchor":"Strategy-Selection"},{"type":"heading","level":3,"text":"Choose Based on Use Case","anchor":"Choose-Based-on-Use-Case"},{"type":"paragraph","inlineContent":[{"text":"Different scenarios require different retry strategies:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ ✅ Fast local operations (file I\/O, cache)","let localRetry = RetryPolicyService(","    strategy: .constant(retry: 3, duration: .milliseconds(100))",")","","\/\/ ✅ Standard API calls","let apiRetry = RetryPolicyService(","    strategy: .exponential(retry: 4, multiplier: 2.0, duration: .seconds(1))",")","","\/\/ ✅ High-traffic services","let highTrafficRetry = RetryPolicyService(","    strategy: .exponentialWithJitter(","        retry: 5,","        jitterFactor: 0.2,","        maxInterval: 60,","        multiplier: 2.0,","        duration: .seconds(1)","    )",")","","\/\/ ❌ Wrong - Too many retries for quick operation","let badRetry = RetryPolicyService(","    strategy: .exponential(retry: 20, duration: .seconds(10))",")"]},{"type":"heading","level":3,"text":"Recommended Configurations","anchor":"Recommended-Configurations"},{"type":"table","header":"row","rows":[[[{"type":"paragraph","inlineContent":[{"text":"Operation Type","type":"text"}]}],[{"inlineContent":[{"text":"Strategy","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Retry Count","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Base Duration","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Notes","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"Cache access","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Constant"}],"type":"paragraph"}],[{"inlineContent":[{"text":"2-3","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"50-100ms","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Fast recovery"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Database query"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Constant","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"3-5","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"100-500ms","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Predictable delays"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"REST API","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Exponential","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"3-4"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"500ms-1s"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Standard backoff","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"GraphQL API","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Exponential"}],"type":"paragraph"}],[{"inlineContent":[{"text":"3-5","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"1-2s","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Handle complex queries","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"File upload","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Exponential + Jitter","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"5-7"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"2-5s"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Large operations","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"text":"Critical payment","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Exponential + Jitter"}],"type":"paragraph"}],[{"inlineContent":[{"text":"5-10","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"1-2s"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Maximum reliability","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"text","text":"Rate-limited API"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Constant"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"3-5"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Based on rate limit","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Respect limits"}],"type":"paragraph"}]]]},{"type":"heading","level":2,"text":"Service Architecture","anchor":"Service-Architecture"},{"type":"heading","level":3,"text":"Reuse Service Instances","anchor":"Reuse-Service-Instances"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Create retry services at the appropriate scope:"}]},{"type":"codeListing","code":["\/\/ ✅ Good - Singleton or service property","class APIClient {","    static let shared = APIClient()","    ","    private let retryService = RetryPolicyService(","        strategy: .exponential(retry: 3, duration: .seconds(1))","    )","    ","    func fetchUser(id: String) async throws -> User {","        try await retryService.retry {","            try await performFetch(id: id)","        }","    }","}","","\/\/ ✅ Good - Dependency injection","class DataRepository {","    private let retryService: RetryPolicyService","    ","    init(retryService: RetryPolicyService = .default) {","        self.retryService = retryService","    }","}","","\/\/ ❌ Bad - Creating new instances repeatedly","func fetchData() async throws -> Data {","    let service = RetryPolicyService(...)  \/\/ Don't do this!","    return try await service.retry { ... }","}"],"syntax":"swift"},{"anchor":"Organize-by-Layer","text":"Organize by Layer","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"Structure retry services by architectural layer:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Network Layer","class NetworkRetryService {","    static let standard = RetryPolicyService(","        strategy: .exponential(retry: 3, duration: .milliseconds(500))","    )","    ","    static let critical = RetryPolicyService(","        strategy: .exponentialWithJitter(","            retry: 5,","            jitterFactor: 0.2,","            maxInterval: 60,","            multiplier: 2.0,","            duration: .seconds(1)","        )","    )","}","","\/\/ Data Layer","class DataRetryService {","    static let cache = RetryPolicyService(","        strategy: .constant(retry: 2, duration: .milliseconds(50))","    )","    ","    static let database = RetryPolicyService(","        strategy: .constant(retry: 3, duration: .milliseconds(200))","    )","}","","\/\/ Usage","class UserRepository {","    func fetchUser(id: String) async throws -> User {","        try await NetworkRetryService.standard.retry {","            try await api.getUser(id: id)","        }","    }","    ","    func cacheUser(_ user: User) async throws {","        try await DataRetryService.cache.retry {","            try cache.save(user)","        }","    }","}"]},{"text":"Error Handling","type":"heading","anchor":"Error-Handling","level":2},{"text":"Selective Retry","type":"heading","anchor":"Selective-Retry","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Don’t retry errors that won’t benefit from retrying:"}]},{"type":"codeListing","syntax":"swift","code":["enum APIError: Error {","    case networkFailure       \/\/ ✅ Retry","    case serverError         \/\/ ✅ Retry (5xx)","    case timeout             \/\/ ✅ Retry","    case rateLimited         \/\/ ✅ Retry with delay","    case unauthorized        \/\/ ❌ Don't retry (401)","    case forbidden           \/\/ ❌ Don't retry (403)","    case notFound            \/\/ ❌ Don't retry (404)","    case badRequest          \/\/ ❌ Don't retry (400)","    case invalidData         \/\/ ❌ Don't retry","}","","func fetchWithSelectiveRetry() async throws -> Data {","    do {","        return try await retryService.retry({","            try await performRequest()","        }, onFailure: { error in ","            if let error = error as? APIError {","                switch error {","                case .unauthorized, .forbidden, .notFound, .badRequest, .invalidData:","                    \/\/ Don't retry client errors","                    throw error","                case .networkFailure, .serverError, .timeout, .rateLimited:","                    \/\/ These were already retried","                    throw error","            }","        })","    } catch let error {","        throw error","    }","}"]},{"text":"Performance Optimization","type":"heading","anchor":"Performance-Optimization","level":2},{"text":"Avoid Over-Retrying","type":"heading","anchor":"Avoid-Over-Retrying","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Balance persistence with resource usage:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ ❌ Bad - Too aggressive","let badService = RetryPolicyService(","    strategy: .constant(retry: 100, duration: .milliseconds(10))",")","","\/\/ ✅ Good - Reasonable limits","let goodService = RetryPolicyService(","    strategy: .exponentialWithJitter(","        retry: 5,","        maxInterval: 60,","        duration: .seconds(1)","    )",")"]},{"text":"Set Appropriate Timeouts","type":"heading","anchor":"Set-Appropriate-Timeouts","level":3},{"type":"paragraph","inlineContent":[{"text":"Combine retries with timeouts to prevent indefinite waiting:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["func fetchWithTimeout<T: Sendable>(","    timeout: TimeInterval,","    operation: @Sendable @escaping () async throws -> T",") async throws -> T {","    try await withThrowingTaskGroup(of: T.self) { group in","        group.addTask {","            try await retryService.retry(operation)","        }","        ","        group.addTask {","            try await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))","            throw TimeoutError.exceeded","        }","        ","        let result = try await group.next()!","        group.cancelAll()","        return result","    }","}"]},{"text":"Testing","type":"heading","anchor":"Testing","level":2},{"text":"Mock Retry Behavior","type":"heading","anchor":"Mock-Retry-Behavior","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Create testable retry scenarios:"}]},{"type":"codeListing","syntax":"swift","code":["actor MockService {","    var failureCount: Int","    private var currentAttempt = 0","    ","    init(failureCount: Int) {","        self.failureCount = failureCount","    }","    ","    func operation() throws -> String {","        currentAttempt += 1","        if currentAttempt <= failureCount {","            throw MockError.transient","        }","        return \"Success\"","    }","}","","\/\/ Test","func testRetrySucceedsAfterFailures() async throws {","    let mock = MockService(failureCount: 2)","    let service = RetryPolicyService(","        strategy: .constant(retry: 3, duration: .milliseconds(10))","    )","    ","    let result = try await service.retry {","        try await mock.operation()","    }","    ","    XCTAssertEqual(result, \"Success\")","}"]},{"text":"Test Strategy Behavior","type":"heading","anchor":"Test-Strategy-Behavior","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Verify retry timing and attempts:"}]},{"type":"codeListing","syntax":"swift","code":["func testExponentialBackoff() async throws {","    let startTime = Date()","    var attempts = 0","    ","    do {","        try await retryService.retry {","            attempts += 1","            throw TestError.failed","        }","    } catch {","        \/\/ Expected to fail","    }","    ","    let duration = Date().timeIntervalSince(startTime)","    ","    XCTAssertEqual(attempts, 4)  \/\/ Initial + 3 retries","    XCTAssertGreaterThan(duration, 7.0)  \/\/ 1 + 2 + 4 seconds","}"]},{"text":"Common Pitfalls","type":"heading","anchor":"Common-Pitfalls","level":2},{"text":"Don’t Retry Non-Idempotent Operations","type":"heading","anchor":"Dont-Retry-Non-Idempotent-Operations","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Be careful with operations that shouldn’t be repeated:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ ❌ Dangerous - May create duplicate payments","func processPayment(amount: Decimal) async throws {","    try await retryService.retry {","        try await paymentGateway.charge(amount)","    }","}","","\/\/ ✅ Safe - Use idempotency key","func processPayment(amount: Decimal, idempotencyKey: String) async throws {","    try await retryService.retry {","        try await paymentGateway.charge(","            amount: amount,","            idempotencyKey: idempotencyKey","        )","    }","}"]},{"text":"Don’t Ignore Cancellation","type":"heading","anchor":"Dont-Ignore-Cancellation","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Respect task cancellation:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ ✅ Good - Check cancellation","try await retryService.retry {","    try Task.checkCancellation()","    return try await operation()","}","","\/\/ ❌ Bad - Ignores cancellation","try await retryService.retry {","    return try await operation()  \/\/ May continue after cancel","}"]},{"text":"Don’t Nest Retries","type":"heading","anchor":"Dont-Nest-Retries","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Avoid multiple retry layers:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ ❌ Bad - Nested retries multiply attempts","func fetch() async throws -> Data {","    try await outerRetry.retry {","        try await innerRetry.retry {  \/\/ Don't do this!","            try await actualFetch()","        }","    }","}","","\/\/ ✅ Good - Single retry layer","func fetch() async throws -> Data {","    try await retryService.retry {","        try await actualFetch()","    }","}"]}],"kind":"content"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/typhoon\/best-practices"]}],"schemaVersion":{"patch":0,"minor":3,"major":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/best-practices"},"hierarchy":{"paths":[["doc:\/\/typhoon.Typhoon\/documentation\/Typhoon"]]},"kind":"article","metadata":{"role":"article","title":"Best Practices","modules":[{"name":"Typhoon"}],"roleHeading":"Article"},"sections":[],"abstract":[{"text":"Learn the recommended patterns and practices for using Typhoon effectively.","type":"text"}],"references":{"doc://typhoon.Typhoon/documentation/Typhoon/RetryPolicyService":{"type":"topic","role":"symbol","abstract":[{"type":"codeVoice","code":"RetryPolicyService"},{"type":"text","text":" provides a high-level API for retrying asynchronous"},{"type":"text","text":" "},{"type":"text","text":"operations using configurable retry strategies."}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"RetryPolicyService"}],"identifier":"doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/RetryPolicyService","kind":"symbol","title":"RetryPolicyService","url":"\/documentation\/typhoon\/retrypolicyservice","navigatorTitle":[{"kind":"identifier","text":"RetryPolicyService"}]},"doc://typhoon.Typhoon/documentation/Typhoon/advanced-retry-strategies":{"abstract":[{"type":"text","text":"Master advanced retry patterns and optimization techniques."}],"identifier":"doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/advanced-retry-strategies","role":"article","title":"Advanced Retry Strategies","type":"topic","kind":"article","url":"\/documentation\/typhoon\/advanced-retry-strategies"},"doc://typhoon.Typhoon/documentation/Typhoon":{"abstract":[],"url":"\/documentation\/typhoon","identifier":"doc:\/\/typhoon.Typhoon\/documentation\/Typhoon","kind":"symbol","role":"collection","title":"Typhoon","type":"topic"},"doc://typhoon.Typhoon/documentation/Typhoon/installation":{"title":"Installation","type":"topic","abstract":[{"type":"text","text":"A guide to installing the Typhoon package into your Swift project using Swift Package Manager."}],"url":"\/documentation\/typhoon\/installation","role":"article","kind":"article","identifier":"doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/installation"},"doc://typhoon.Typhoon/documentation/Typhoon/quick-start":{"type":"topic","role":"article","abstract":[{"type":"text","text":"Get up and running with Typhoon in minutes."}],"identifier":"doc:\/\/typhoon.Typhoon\/documentation\/Typhoon\/quick-start","title":"Quick Start","kind":"article","url":"\/documentation\/typhoon\/quick-start"}}}